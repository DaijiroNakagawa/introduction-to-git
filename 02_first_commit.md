## ひとりで使うgit

さて、git がどんなものなのか、だいたいわかったでしょうか。というわけで、まずは、ひとりで git を使ってみましょう。

## まずはリポジトリを作ろう

なにはともあれ、まずはリポジトリを作らなくては話ははじまりません。リポジトリを作りましょう。

    $ mkdir my_first_workspace
    $ cd my_first_workspace
    $ git init

$ mkdir my_first_workspace で、 my_first_workspace という「作業ディレクトリ」を作りました。$ cd my_first_workspace で、そのディレクトリに入りました。そこで、$ git init をすることで、この作業ディレクトリに対応するリポジトリを作成しています。

「作業ディレクトリ」と「リポジトリ」の関係は頭に入ってますか？ 頭に入ってないひとは [VCS入門](https://github.com/masaru-b-cl/introduction-to-vcs/blob/master/readme.md) をおさらいしましょう。

さて、これで、「作業ディレクトリ」と「リポジトリ」が出来上がりました。が、リポジトリは一体どこにつくられたのでしょうか？my_first_workspace ディレクトリにいる状態で、

    $ ls -a

としてみましょう。すると、下記のように、".git" というディレクトリが存在しているのが見て取れると思います(ちなみに、 "." というのは現在のディレクトリ を指し、 ".." というのは一個うえのディレクトリのことです)。

    $ ls -a
    .    ..   .git
 
この ".git" ディレクトリが、「リポジトリ」の正体です。workspace という「作業ディレクトリ」があるとき、その作業ディレクトリに対応する「リポジトリ」は、 workspace/.git である、ということですね。
 
今はコマンドラインから見てみましたが、ファイラーから見てみましょう(ここから先は mac 環境であることを前提とします)。Finder で、my_first_workspace ディレクトリを開いてみましょう。
 
あれっ！？ ".git" が無いように見えますね！？ これは、 "." から始まるファイルやディレクトリは「隠しファイル」であるせいです。隠しファイルは、Finderからは見えなくなっています。大切な設定情報などが書き込まれているファイルは、誤操作で消してしまったりしないように、"." から始まる「隠しファイル」とされることが多いです。誤操作でリポジトリがふっとんじゃった！なんてことになったら、目もあてられないので、リポジトリは隠しファイルとなっているわけですね。Finder から隠しファイルを見れるようにする方法もあるのですが、ここでは脇道にそれてしまうため触れません。
 
とにかく、これで、「作業ディレクトリ」の "my_first_workspace" と、それに対応する「リポジトリ」である ".git" が出来上がりました。この「作業ディレクトリ」の中で編集されるファイル群が、「作業コピー」となります。

ちなみに、作業コピーの内容をリポジトリに登録することを、「コミット」と言いますので、覚えておきましょう。

## 作業ディレクトリで作業をしよう

まずは、作業ディレクトリの中になにかファイルを作って見ましょう。どのようなやり方でもかまいません。いまはとりあえず

    nyan

と書かれた nyan.txt というファイルを作業ディレクトリ内に作ってください。

作りましたか？

これで、「リポジトリに反映されていない作業コピー」が「作業ディレクトリ内」に保できあがりました。その様子を見てみましょう。ターミナルで作業ディレクトリに入って、現在の「リポジトリと作業コピーの状態」を見てみましょう

    $ cd path/to/my_first_workspace
    $ git status

path/to/my_first_workspace はおのおの自分が my_first_workspace を作ったパスに読み替えてください。

さて、上記のようにコマンドを打ってみると、

    # On branch master
    #
    # Initial commit
    #
    # Untracked files:
    #   (use "git add <file>..." to include in what will be committed)
    #
    #	nyan.txt
    nothing added to commit but untracked files present (use "git add" to track)

というような表示が出てきたかと思います。「ウワァ英語だ！助けて！」みたいにならないでください。少なくとも中学で3年間、多くのひとはそのあと高校で3年間はみっちり英語習ってきたでしょう。これくらいは読みましょう。

まず上から見ていきましょう。"On branch master"とありますね。「ブランチ master 上だよ」と言っています。ブランチについて説明していないので、いまはこれは無視してかまいません。

そのあとに Initial commit と書かれていますね。「最初のコミットだよ」と書かれています。まだ一度もコミットしていないので、「この作業コピーをコミットするとこれが最初のコミットになるよ」って意味です。

そのあと、"Untracked files" と書かれていますね。「トラックされていないファイルたちだよ」と言っています、このトラックは、「追跡する」の意味ですね。つまり、「追跡されてないファイルだよ」という意味です。「追跡されていない」とはどういうことでしょうか。だれが追跡していないのでしょうか。

これは、「作業コピーにこういうファイルがあるけど、リポジトリはそれを追跡してないよ」という意味です。つまり、リポジトリさんが、「なんか知らんファイルあるよ、おれこれ知らんよ」って言ってるわけですね。括弧の中はいったん飛ばして、その下を見てみると、先ほど作った nyan.txt が書かれています。新しく作ったファイルだから、「おれこれ知らないファイルなんだけどいいの？」とリポジトリさんが言ってくれてるのですね。

では、括弧の中を見てみましょう。 use "git add <file> ..." to include in what will be committed と書かれています。なんて親切な git さん、「知らんファイルあるんだけどさ、これもコミットしたいなら git add <file> ってやってくれればいいよ」と教えてくれています。

最後に、nothing added to commit but untracked files present (use "git add" to track) と書かれていますね。「コミットするものがなにもないよ、でも追跡されてないファイルがあるよ(追跡したければ git add するといいよ)」と説明してくれています。

英語、ちゃんと読めば、これだけ丁寧に情報が書かれているんです。たまに「なんか表示されたけど英語だから読まなかったです」みたいなひといるけど、読んでください。ググるまでもなく、ひとに聞くまでもなく、ちゃんと読めばちゃんと情報が出ているんです。

さて、上記をまとめると、「nyan.txt」っていうファイルが作業コピー内にあるけど、リポジトリはそのファイルのこと追跡してないよ状態になっているわけですね。

## 作業ディレクトリで作業をしよう、の落ち穂拾い

さて、さきほど $ git status を打ったときの出力ですが、

    # On branch master
    #
    # Initial commit
    #
    # Untracked files:
    #   (use "git add <file>..." to include in what will be committed)
    #
    #	.DS_Store
    #	nyan.txt
    nothing added to commit but untracked files present (use "git add" to track)
    
という感じで、身に覚えない .DS_Store というファイルが「untracked files」として表示されてしまったひともいるかもしれません。この .DS_Store というファイルは、mac OS が勝手に作る、「このフォルダのアイコンの並び順はこんな感じで表示サイズはこのくらい」みたいな情報が入ったファイルです。このファイルは、リポジトリで管理する必要のないファイルですね。むしろ、このファイルはそれぞれの環境によって異なる内容になるので、リポジトリで管理すると無用なトラブルのもとになります。こういうときには、「.DS_Storeっていうファイル、無視してね」と git に教えてあげましょう。その方法はふたつあります。

1. .gitignore という、「このファイルはこのリポジトリでは無視してね」を書いたファイルをリポジトリに作成する
2. どのリポジトリでも .DS_Store という名前のファイルを無視するように git を設定する

「このリポジトリでは無視したいファイルなんだけどグローバルに無視したいわけではない」みたいなファイルは .gitignore に書く方法がいいでしょうし、どんな場合にも無視してほしいようなファイルに関してはグローバルに無視する設定をしたほうがいいでしょう。今回の .DS_Store はどんな場合にもリポジトリ管理したくない類いのものだと思いますので、今回はその方法を取りましょう。ターミナルを開いて、以下のコマンドを打ってください。

    $ git config --global core.excludesfile ~/.gitignore_global
    $ echo ".DS_Store" >> ~/.gitignore_global

一行目で、「グローバルに無視するファイル名を書いたファイルは ~/.gitignore_global というファイルだよ」とgitに教えてあげています。二行目で、そのファイルに ".DS_Store" を書き込み、gitに「.DS_Store」は無視してねと教えています。

.gitignoreファイルの書き方には触れないので、グーグル先生に聞いてください。

さて、ここで再度

    $ git status

してみましょう。今度は、.DS_Store が「untracking files」から消えて、git が完全にその存在を無視していることが見て取れるでしょう。

## 作業コピーの内容を track してもらう

さて、作業コピーで新しいファイルを作った状態では、そのファイルは untracking な状態でした。では、この untracking な状態のファイルを、リポジトリに track してもらいましょう。その方法をあなたはもう知っているはずです。そうです。 git add ですね。ではやってみましょう。

    $ git add nyan.txt

これで、「nyan.txtを track してね」とリポジトリに伝える事ができました。ではここで再度 git status してみましょう。

    $ git status
    # On branch master
    #
    # Initial commit
    #
    # Changes to be committed:
    #   (use "git rm --cached <file>..." to unstage)
    #
    #	new file:   nyan.txt
    #

このような出力が得られたかと思います。ちょっと内容が変わってますね。英語だけど頑張って読んでみましょう。

Initial commit のところまではいいでしょう。その下、Changes to be committed: と書かれていますね。これはそのまま、「コミットされる変更だよ」です。つまり、この状態でコミットをすると、その下に書かれた内容がコミットされるよ、ということですね。括弧を飛ばしてみて見ると、new file: nyan.txt と書かれています。つまり、この状態でコミットをすると「新しく nyan.txt というファイルが作られたよ」という変更内容がコミットされるよ！ということですね。いい感じです！

括弧のなかにはなんて書いてあるでしょうか。 use "git rm --cached <file>..." to unstage ですね。「unstage するには、 "git rm --cached <file>..." ってすればいいよ」とのことです。ん？ 新しい疑問が生まれましたね。unstageとはなんでしょうか。では stage unstage について説明しましょう。

## stage とは unstage とは

git では、作業ディレクトリで作業コピーに編集を加えたものを、そのまま直にリポジトリにコミットすることができません。コミットするときには、かならず、「あ、このファイルはコミット(リポジトリに変更を反映)してほしいファイルね。このファイルは編集してあるんだけどまだリポジトリに反映したくないからコミットしないで」みたいな感じで、「どの変更内容はコミットするけどどの変更内容はコミットしない」みたいなのを先に git に教えておく必要があります。このときgitに教えてあげた「次コミットするときにリポジトリに反映される内容」の置き場のことを、stage と呼んでいます。

つまり、さっき git add nyan.txt としたことで、nyan.txtはその内容が「staging された」ことになります。ではunstage とは？もうお分かりでしょう。「stage」が「これはコミットしてほしい変更内容ね」と git に教えることなので、その逆、「あっやっぱこの変更内容は次のコミットでコミットすんのやめて」と git に教えることになるわkです。では、実際にやってみましょう。 use "git rm --cached <file>..." to unstage でしたね。今回は nyan.txt をunstageするので、以下のようになります。

    $ git rm --cached nyan.txt

はい、ではここでもう一度 git status で状態を見てみましょう

    $ git status
    # On branch master
    #
    # Initial commit
    #
    # Untracked files:
    #   (use "git add <file>..." to include in what will be committed)
    #
    #	nyan.txt
    nothing added to commit but untracked files present (use "git add" to track)
    
おおー。nyna.txt が Untracked files に戻っていますね。

こんな感じで、git に「作業ディレクトリで作業コピーにたいして行った変更のうち、どの変更をコミットするのか、あるいはしないのか」を教えて上げることができます。では、とりあえず今回は再度 nyan.txt を stage に上げておきましょう。

    $ git add nyan.txt
    
    $ git status
    # On branch master
    #
    # Initial commit
    #
    # Changes to be committed:
    #   (use "git rm --cached <file>..." to unstage)
    #
    #	new file:   nyan.txt
    #

## ついにcommitしてみよう

さて、それでは、ついに commit をしてみましょう。コミットをするには、

    $ git commit

です。 git commit とすると、エディタが立ち上がります。おそらく vi というターミナル内で動くエディタが立ち上がったのではないでしょうか($EDITORを設定してるような中級者以上の読者は想定してないのでそのへんは自分で読み替えてください)。vi の使いかたについてはここでは触れないので、Google先生に聞いてください。慣れると使いやすいですよ。

さて、エディタが立ち上がった画面には、先ほど git status で確認したのと似たような、でもちょっとだけ違うものが出力されているかとおもいます。では、また英語を読みましょう。何度も言うけど、出力された英語をちゃんと読めば必要な情報はそこに書いてあります。四の五の言わずに読んでください。

    # Please enter the commit message for your changes. Lines starting
    # with '#' will be ignored, and an empty message aborts the commit.
    # On branch master
    #
    # Initial commit
    #
    # Changes to be committed:
    #   (use "git rm --cached <file>..." to unstage)
    #
    #       new file:   nyan.txt
    #

On branch master 以下については前みた通りなので説明しなくていいですね。さて、なんと書いてありますか？

「君がやった変更についてのコミットメッセージを書いてくれよな！ '#'で始まる行は無視するぜ！空のメッセージ書きやがったらこのコミットを中止するからな！」と書いてあります。git さんのキャラがぶれてきている気がしますがまあ気にせず進めましょう。

ところで、では「コミットメッセージ」とはなんでしょうか。コミットを進める前に、コミットメッセージについて少し話をしておきましょう。

## コミットメッセージとは？

何度も参照している [VSC入門](https://github.com/masaru-b-cl/introduction-to-vcs/blob/master/readme.md) を紐解いてみましょう。

> ## VCSの力
> VCSの能力は、主に次の2つです。
> 
> 1. 履歴を残す
> 1. 作業の競合を防ぐ
> 
> [VCS入門](https://github.com/masaru-b-cl/introduction-to-vcs/blob/master/2.power-of-vcs.md#vcs)より

この、「履歴を残す」というのは、「誰が」「いつ」「何を」したかを残すということでしたね。「誰が」「いつ」の履歴を残すところまでは git が面倒を見てくれますが、「何を」したかまでは、git はわかりません。もちろん、「どのファイルを編集した」とかはわかるのですが、ここで言う「何をしたか」というのは、そういう細かい粒度の話ではなくて、もっと現実世界の話、つまり、「ほげほげがふがふがしてしまうバグを直した」だとか、「ほげほげ画面にふがふが機能を追加した」とか、そういう話です。こういう「何をしたか」を書いておくためのものが、「コミットメッセージ」です。こういうメッセージを残しておくことで、あとで履歴を見るときに「なるほどなるほど〜」と言いながら見ることができるわけですね。ちなみに、良いコミットメッセージとはどんなメッセージなのかということも、さきほどの VCS 入門に書かれています。熟読しておきましょう。

## 今度こそ commit してみよう

さて、コミットメッセージとはなにかがわかったところで、コミットメッセージを書いてみましょう。今回だと「猫の鳴き声を管理するファイルを作成」という感じでしょうか。

'#'から始まる行は無視される、とあるので、#から始めずに、「猫の鳴き声を管理するファイルを作成」というメッセージを書いて、保存、エディタを終了してみましょう。

    $ git commit
    [master (root-commit) 33028c1] 猫の鳴き声を管理するファイルを作成
     1 file changed, 1 insertion(+)
     create mode 100644 nyan.txt

終了したらこんな感じになりました。なんかいろいろ出てきましたね。おめでとうございます！これで、初めてのコミットができました！コミットするまで結構長かったですね！

## じゃあ履歴を見てみましょう

VSC の能力として、「履歴を残す」というのがあると言いました。では履歴を見てみましょう。git log で見れます

    $ git log
    commit 33028c115cc19cf6122fc2004fc6393a22712d23
    Author: Shinpei Maruyama <shinpeim@gmail.com>
    Date:   Fri May 3 22:32:52 2013 +0900

    猫の鳴き声を管理するファイルを作成

お、ちゃんと履歴が残っていますね。一行目になんかおそろしげな文字列がありますが、次に説明するのでとりあえず無視しましょう。その下のAuthorのに「だれが」が、さらにその下の Date に「いつ」が、その下に「何を」行ったかがきちんとリポジトリに登録されています。yippie！

## コミットされると何が起こるのか

まだまだこの章は終わりません。コミットしたとき、リポジトリになにが起こっているのでしょうか。それを見てみましょう。

簡単に言うと、コミットする、というのは、リポジトリに「コミットオブジェクト」というものを作るということを意味します。では「コミットオブジェクト」とは一体なんなのでしょうか。

簡単に言うと、コミットオブジェクトは、「その時点でのリポジトリのスナップショット」みたいなものです。git commit したことにより、stageされていた内容が、コミットメッセージとともに「コミットオブジェクト」となり、リポジトリに大切にしまわれた、という感じです。次にまたなにかを変更してそれをコミットすると、また新しいコミットオブジェクトが作られ、リポジトリにしまわれます。それぞれのコミットオブジェクトには一意の id がついていて、それがさっきみた謎の文字列です。

    commit 33028c115cc19cf6122fc2004fc6393a22712d23

これは、このコミットオブジェクトの id が "33028c115cc19cf6122fc2004fc6393a22712d23" だよ、ということを表しているのですね。

ひとまず今はそんなふうに思っておいてください。